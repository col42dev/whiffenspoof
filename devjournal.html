<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>dev journal</title>
        <link rel="stylesheet" href="./src/css/bootstrap.css">
        <link rel="stylesheet" href="./src/css/docs.css">
     
    </head>
    <body>
        <div>

        </div>
        <p>whiffenspoof arose from a task set for me by professor Pittaway at Brunel university. I've used this previously as hello-world type app for 
           learning new platforms, in this case javascript. Its a simple slider puzzle which requires the basic I/O and rendering with some state storage 
           and box collsion handling. I had used javascript previously but had never taken the time to <em>learn</em> it, 
           I had been able to patch together simple programs but it seemed too foriegn for use in anything larger scale. 
           As a starting point I read <a href="http://effectivejs.com/">http://effectivejs.com/</a> and listened to <a href="http://javascriptjabber.com/">http://javascriptjabber.com/</a>.
           
           I wanted to include some shared libraries in this project as a learning exercise. The collision detection for whiffenspoof is straight forward
           aligned box collision and is a good candidate for using shared libraries. I selected <a href="https://github.com/jriecken/sat-js">https://github.com/jriecken/sat-js</a> for this.
           The rendering component is also simple but I wanted to see if I could use a shared library here to. For this I found <a href="http://fabricjs.com/">http://fabricjs.com/</a>, the 
           many examples on this site show that it can combine canvas support with mouse handling and some collision detection. At this point I 
           decided I could switch to fabricjs for providing these components in whiffenspoof. I tried to mock up a test case doing this but found 
           that I could not get control of the collision detection without fully understanding the libraries implmentation, which wasn't an 
           original objective of the project. So I switched back to sat-js and proceeded to implement the canvas and input handling from basics.
           
           I intentionally avoided JQuery so as to get a better understanding of the core javascript API. 
           Effective JS mentoned <a href="http://www.jslint.com/">http://www.jslint.com/</a> gor code analysisi. Looking for a command line alternative  
           I installed <a href="http://www.jshint.com">http://www.jshint.com</a> and set it up for use in my editors console window.
           
           Starting with a single JS file I wrapped this in a an <a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression">IFFY</a>. 
           Once I had some core game functionality in place I adopted <a href="http://requirejs.org/">http://requirejs.org/</a> to modularize and refactor it out. 
           This made it clear how a javascript project could pratically be extended to a larger scale and using object orientation.
           
           
           The canvas render size was initially fixed, I generalized this to fit to the device view size to make the most of the available screen space.
           At this point the performance differences between iPad and desktop browsers became more apparrent, iPad Safari has low framerate when sliding the tiles.
           I didn't have any system support for profiling or any of my own profiling so I took a guess that this must be due to the canvas redrawing. Now that the 
           canvas resized on device specs it was apparent that the landscape mode which used a smaller canvas was faster than portrait. The initial implementation 
           of the canvas render was to clear the full canvas on every update loop and redraw it. So i looked at implemenating a dirty rectangle refresh in place of this.
           The rectangular layout of the tiles made this straight forward. Initially i tried moving the render and refresh calls in to the IO event handler callbacks.
           This almost worked but it tied the rendering to these callbacks which broke the model-view pattern. So i moved render back in to a cebtralized update loop
           and implemented the dirty rectangle refresh here. This made a very noticeable improvement to the framerate on iOS. 
        
           Front-end<br/>
           I went through several learning iterations with the front-end and screen state implementation. Initially I implmented the screen state as seperate html files
           but discoved that this does not fit well with a standard browser. The refresh would simple refresh the existing screen rather than return you to the front-end
           for example. To maintain more control over this I switched to use of a single html page and dynamically control the html to switch screen states. This did the 
           trick but resulted in an cumbersome implementation. The quantum leap was to then switch to using the <a href="http://angularjs.org/">http://angularjs.org/</a>
           MVC framework.   
           
           Server-side architecture<br/>
           NodeJS + Express.
           Run the express app from the console and end command with & to signify hat it should run in tha backgound. The task id
           can be located using 'ps -A | grep Node'
           Start with storing JSON data within the NodeJS app before moving it in to a database. This allows for the client-server
           communication to be implmentented with no database dependancy. In Angular the http REST API provides the GET,PUT to transfer 
           the JSON score table data. Starting with the GET it was necessary to configure the client for CORS(cross-origin resource sharing)
           so that the XHR would succeed.
           
           
           npm install mongojs
           mongodb/bin/mongod&
           nginx/html/mongodb/bin/mongod --fork --logpath /var/log/mongodb.log
           mongodb/bin/mongod --fork --logpath /data/db/mongodb.log
           
           /whiffenspoof
           mongodb/bin/mongod --fork --logpath /data/db/mongodb.log

            /whiffenspoof
           node scoretableApp.js& will terminate when you logout of a session.
           
            nohup node scoretableApp.js >/dev/null 2>&1 &

            sudo nano /etc/nginx/nginx.conf
            sudo service nginx restart
            
            http://howtonode.org/node-js-and-mongodb-getting-started-with-mongojs
            http://blog.ijasoneverett.com/2013/03/a-sample-app-with-node-js-express-and-mongodb-part-1/
            http://ec2-54-213-75-45.us-west-2.compute.amazonaws.com/whiffenspoof/redshift.html#/scores
            
            


             
        </p>

    </body>
</html>
